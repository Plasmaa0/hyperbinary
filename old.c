
//функции не используются, остались от прошлых версий
/*
int floor2pow(int x) //СТАРАЯ ВЕРСИЯ  //возвращается наибольшую степень двойки ex, при которой 2^ex < X используя frexp()
{
    double result;
    int ex;
    result = frexp(x, &ex);
    ex += ((int)result == 1) ? (-2) : (-1);
    return ex;
}

int C_all(int n) //количество всех возможных сочетаний из n (без установки определенного количества чисел в сочетаннии)
{
    int sum = 0;
    for (int i = 0; i < n; i++)
    {
        sum += C(n, i);
    }
    return sum;
}

// изначально думал что функция ниже - swapall(), является решением задачи
// но потом понял, что она выдаёт неполное решение.
// Оставил тут для возможной доработки программы.
int swapall(int *input, int length, int *output) //upd: заменяет сразу всё, что может, т.е. упускает варианты, где не все замены проведены
{                                                //Генерирует варианты в двоичной системе с 2
    for (int i = 0, j = 0; i < length; i++, j++) //input - массив цифр исходного числа;
    {                                            //output - массив цифр выходного числа;
        output[j] = input[i];                    //length - количество цифр исходного числа
    }                                            //Проходит по всем парам цифер входного числа и изменяет их, используя два правила:
    int changes = 0;                             //1 Правило: 10 -> 02
    for (int i = 0; i < length - 1; i++)         //2 Правило: 20 -> 12
    {                                            //Возвращает длину полученной строки
        switch (canswap(input, length, i))       //Если не было внесено ни одного изменения, то возвращает -1
        {                                        //ВАЖНО: применяет изменения разом на всю строку. !!!!!!!!!!!!!!!!!!!!!!!
        case 1:
            if (input[i + 1] == 0)
            {
                output[i] = 0;
                i++;
                output[i] = 2;
                changes = 1;
            }
            break;
        case 2:
            if (input[i + 1] == 0)
            {
                output[i] = 1;
                i++;
                output[i] = 2;
                changes = 1;
            }
            break;
        default:
            break;
        }
    }
    if (changes == 0)
    {
        return -1;
    }
    return length;
}
*/
//